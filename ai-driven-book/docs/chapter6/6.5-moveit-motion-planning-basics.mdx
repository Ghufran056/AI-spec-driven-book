---
id: 6.5-moveit-motion-planning-basics
title: MoveIt Motion Planning Basics
sidebar_label: 6.5 - MoveIt Motion Planning Basics
---

# MoveIt Motion Planning Basics

## Learning Objectives

By the end of this lesson, you will be able to:
- Understand the fundamental concepts and architecture of the MoveIt framework
- Configure and use MoveIt for basic motion planning tasks
- Set up MoveIt for a custom robotic arm configuration
- Implement motion planning with collision avoidance
- Use MoveIt's planning interfaces and visualization tools
- Integrate MoveIt with ROS/ROS 2 manipulation pipelines

## Introduction

MoveIt is the de facto standard motion planning framework for ROS and ROS 2, providing a comprehensive set of tools and libraries for robotic manipulation and motion planning. It integrates state-of-the-art motion planning algorithms, collision detection, kinematic solvers, and trajectory execution into a unified framework that enables robots to plan and execute complex motions while avoiding obstacles and respecting joint limits. MoveIt has become essential for robotic manipulation research and applications, offering both high-level planning capabilities and low-level control interfaces.

The framework provides a modular architecture that allows users to customize different components based on their specific requirements. It includes support for various planning algorithms such as RRT, RRTConnect, and CHOMP, as well as integration with physics simulators like Gazebo and real robot hardware. MoveIt's flexibility and extensive documentation have made it the go-to solution for motion planning in the robotics community.

MoveIt handles many of the complex aspects of motion planning automatically, including inverse kinematics, collision checking, and trajectory generation. However, understanding its architecture and configuration is crucial for effective use, especially when working with custom robot configurations or specialized applications. The framework also provides extensive visualization tools through RViz that help users debug and understand the planning process.

## Main Theory

### 1. MoveIt Architecture
MoveIt's architecture consists of multiple interconnected components including the planning scene, motion planners, collision detection, kinematic solvers, and trajectory execution modules that work together to enable motion planning.

### 2. Planning Scene Representation
The planning scene maintains the robot state and the environment, including static and dynamic obstacles, allowing the planner to generate collision-free trajectories.

### 3. Motion Planning Algorithms
MoveIt supports various motion planning algorithms such as RRT, RRTConnect, LazyPRM, and TrajOpt, each with different characteristics for different types of planning problems.

### 4. Inverse Kinematics Integration
MoveIt integrates with various IK solvers to efficiently compute joint configurations for desired end-effector poses, supporting both analytical and numerical approaches.

### 5. Collision Detection and Avoidance
MoveIt uses FCL (Flexible Collision Library) and Bullet for efficient collision detection, enabling safe motion planning in complex environments.

### 6. Trajectory Generation and Execution
MoveIt generates smooth, executable trajectories and provides interfaces for executing them on real or simulated robots.

```
MoveIt Architecture:

[Planning Request] → [Planning Scene] → [Motion Planner] → [Trajectory] → [Execution]
      ↑                   ↑                  ↑              ↑           ↑
[User Interface] ←→ [Collision Checking] ←→ [IK Solver] ←→ [Filters] ←→ [Controllers]
```

## Examples

### Example: MoveIt Configuration Files
```xml
<!-- config/joint_limits.yaml -->
# Joint limit definitions for MoveIt
joint_limits:
  joint1:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
  joint2:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
  joint3:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
  joint4:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
  joint5:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
  joint6:
    has_velocity_limits: true
    max_velocity: 1.0
    has_acceleration_limits: true
    max_acceleration: 0.5
```

```yaml
# config/kinematics.yaml
# Kinematic solver configuration for MoveIt
manipulator:
  kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin
  kinematics_solver_search_resolution: 0.005
  kinematics_solver_timeout: 0.005
  kinematics_solver_attempts: 3
```

```yaml
# config/ompl_planning.yaml
# OMPL planning configuration for MoveIt
planner_configs:
  SBLkConfigDefault:
    type: geometric::SBL
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
  ESTkConfigDefault:
    type: geometric::EST
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    goal_bias: 0.05  # When close to goal select goal, def: 0.05
  LBKPIECEkConfigDefault:
    type: geometric::LBKPIECE
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9
    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5
  BKPIECEkConfigDefault:
    type: geometric::BKPIECE
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9 (0.5)
    failed_expansion_score_factor: 0.5  # When to disregard type, def: 0.5
    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5
  KPIECEkConfigDefault:
    type: geometric::KPIECE
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    goal_bias: 0.05  # When close to goal select goal, def: 0.05
    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9 (0.5)
    failed_expansion_score_factor: 0.5  # When to disregard type, def: 0.5
    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5
  RRTkConfigDefault:
    type: geometric::RRT
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    goal_bias: 0.05  # When close to goal select goal, def: 0.05
  RRTConnectkConfigDefault:
    type: geometric::RRTConnect
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
  RRTstarkConfigDefault:
    type: geometric::RRTstar
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    goal_bias: 0.05  # When close to goal select goal, def: 0.05
    delay_collision_checking: 1  # Stop collision checking after a delay, def: 1
  TRRTkConfigDefault:
    type: geometric::TRRT
    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)
    goal_bias: 0.05  # When close to goal select goal, def: 0.05
    max_states_failed: 10  # When to start increasing temp, def: 10
    temp_change_factor: 2.0  # How much to increase or decrease temp, def: 2.0
    min_temperature: 10e-10  # Lower limit of temp change, def: 10e-10
    init_temperature: 10e-6  # Initial temperature, def: 10e-6
    frountier_threshold: 0.0  # Dist new state to nearest free in tree, def: 0.0 (0.2)
    frountierNodeRatio: 0.1  # Near frontier bias, def: 0.1 (0.0)
    k_constant: 1.0  # Value used to normalize expresssion, def: 1.0 (0.0)

manipulator:
  planner_configs:
    - SBLkConfigDefault
    - ESTkConfigDefault
    - LBKPIECEkConfigDefault
    - BKPIECEkConfigDefault
    - KPIECEkConfigDefault
    - RRTkConfigDefault
    - RRTConnectkConfigDefault
    - RRTstarkConfigDefault
    - TRRTkConfigDefault
  projection_evaluator: joints(joint1,joint2)
  longest_valid_segment_fraction: 0.005
```

### Example: Basic MoveIt Motion Planning Node
```python
import rclpy
from rclpy.node import Node
from moveit_msgs.msg import PlanningScene, PlanningSceneWorld
from moveit_msgs.srv import GetMotionPlan
from moveit_msgs.action import MoveGroup
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import JointState
from trajectory_msgs.msg import JointTrajectory
from builtin_interfaces.msg import Duration
import time

class MoveItMotionPlanner(Node):
    def __init__(self):
        super().__init__('moveit_motion_planner')

        # Initialize MoveIt interfaces
        self.move_group_interface = None  # Would be initialized with actual MoveIt interface
        self.planning_scene_interface = None  # Would be initialized with actual interface

        # Robot state publisher
        self.joint_state_publisher = self.create_publisher(
            JointState,
            '/joint_states',
            10
        )

        # Initialize robot parameters
        self.robot_name = 'manipulator'
        self.group_name = 'manipulator'

        self.get_logger().info('MoveIt Motion Planner initialized')

    def plan_to_pose(self, target_pose):
        """
        Plan motion to a target pose using MoveIt
        """
        # In a real implementation, this would use the MoveIt Python interface
        # For this example, we'll outline the general approach:

        # 1. Set the target pose
        # move_group.set_pose_target(target_pose)

        # 2. Plan the motion
        # plan = move_group.plan()

        # 3. Execute if successful
        # move_group.execute(plan, wait=True)

        # For demonstration purposes, we'll return a simulated plan
        simulated_plan = self.create_simulated_trajectory(target_pose)
        return simulated_plan

    def plan_to_joint_values(self, joint_values):
        """
        Plan motion to specific joint values using MoveIt
        """
        # In a real implementation:
        # move_group.set_joint_value_target(joint_values)
        # plan = move_group.plan()
        # return plan

        # For demonstration:
        simulated_plan = self.create_simulated_joint_trajectory(joint_values)
        return simulated_plan

    def add_collision_object(self, object_name, pose, dimensions):
        """
        Add a collision object to the planning scene
        """
        # In a real implementation, this would use the PlanningSceneInterface
        # planning_scene_interface.add_box(object_name, pose, dimensions)

        self.get_logger().info(f'Added collision object: {object_name}')

    def remove_collision_object(self, object_name):
        """
        Remove a collision object from the planning scene
        """
        # In a real implementation:
        # planning_scene_interface.remove_world_object(object_name)

        self.get_logger().info(f'Removed collision object: {object_name}')

    def create_simulated_trajectory(self, target_pose):
        """
        Create a simulated trajectory for demonstration
        """
        # This would normally be created by MoveIt's planner
        # For simulation purposes:
        trajectory = JointTrajectory()
        trajectory.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']

        # Create a simple trajectory with a few points
        for i in range(5):  # 5 trajectory points
            point = JointTrajectory().points[0] if len(JointTrajectory().points) > 0 else None
            # In a real implementation, this would contain actual joint values
            # calculated by MoveIt's inverse kinematics solver
            pass

        return trajectory

    def create_simulated_joint_trajectory(self, joint_values):
        """
        Create a simulated joint trajectory for demonstration
        """
        trajectory = JointTrajectory()
        trajectory.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']

        # Add trajectory point with target joint values
        from trajectory_msgs.msg import JointTrajectoryPoint
        point = JointTrajectoryPoint()
        point.positions = joint_values
        point.time_from_start = Duration(sec=2, nanosec=0)  # 2 seconds to reach
        trajectory.points = [point]

        return trajectory

def main(args=None):
    rclpy.init(args=args)
    motion_planner = MoveItMotionPlanner()

    # Example: Plan to a target pose
    target_pose = PoseStamped()
    target_pose.header.frame_id = "base_link"
    target_pose.pose.position.x = 0.5
    target_pose.pose.position.y = 0.0
    target_pose.pose.position.z = 0.5
    target_pose.pose.orientation.w = 1.0

    # Plan and execute
    plan = motion_planner.plan_to_pose(target_pose)
    if plan:
        motion_planner.get_logger().info('Motion plan generated successfully')
    else:
        motion_planner.get_logger().info('Failed to generate motion plan')

    # Example: Plan to specific joint values
    joint_values = [0.0, -1.57, 0.0, -1.57, 0.0, 0.0]
    joint_plan = motion_planner.plan_to_joint_values(joint_values)
    if joint_plan:
        motion_planner.get_logger().info('Joint space plan generated successfully')

    motion_planner.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Example: MoveIt Python Interface Usage
```python
# moveit_example.py
import sys
import copy
import rospy
from moveit_commander import RobotCommander, PlanningSceneInterface, MoveGroupCommander
from moveit_msgs.msg import RobotState, RobotTrajectory
from geometry_msgs.msg import Pose, PoseStamped
from std_msgs.msg import String
import tf.transformations as tf_trans

class MoveItExample:
    def __init__(self):
        # Initialize MoveIt commander
        self.robot = RobotCommander()
        self.scene = PlanningSceneInterface()
        self.group = MoveItCommander("manipulator")  # Replace with your group name

        # Allow some time for initialization
        rospy.sleep(2)

    def plan_cartesian_path(self, waypoints, eef_step=0.01, jump_threshold=0.0,
                          avoid_collisions=True):
        """
        Plan a Cartesian path through waypoints
        """
        # Set the start state to current state
        self.group.set_start_state_to_current_state()

        # Plan Cartesian path
        fraction = 0.0
        for attempts in range(5):  # Try up to 5 times
            (plan, fraction) = self.group.compute_cartesian_path(
                waypoints,   # waypoints to follow
                eef_step,    # eef_step
                jump_threshold,  # jump_threshold
                avoid_collisions=avoid_collisions
            )

            if fraction >= 0.95:  # If 95% of path is valid
                return plan
            else:
                rospy.loginfo(f"Cartesian path planning attempt {attempts+1} achieved {fraction*100}% success")

        rospy.logwarn("Failed to plan Cartesian path with high success rate")
        return None

    def plan_to_pose_goal(self, target_pose):
        """
        Plan motion to a target pose
        """
        # Set the pose target
        self.group.set_pose_target(target_pose)

        # Plan to the target
        plan = self.group.plan()

        # Clear the target
        self.group.clear_pose_targets()

        return plan

    def plan_to_joint_goal(self, joint_values):
        """
        Plan motion to joint space goal
        """
        # Set joint value target
        self.group.set_joint_value_target(joint_values)

        # Plan to the target
        plan = self.group.plan()

        # Clear the target
        self.group.clear_pose_targets()

        return plan

    def execute_plan(self, plan):
        """
        Execute a planned trajectory
        """
        return self.group.execute(plan, wait=True)

    def add_collision_objects(self):
        """
        Add collision objects to the planning scene
        """
        # Add a table as a collision object
        table_pose = PoseStamped()
        table_pose.header.frame_id = self.robot.get_planning_frame()
        table_pose.pose.position.x = 0.5
        table_pose.pose.position.y = 0.0
        table_pose.pose.position.z = 0.0
        table_pose.pose.orientation.w = 1.0

        self.scene.add_box("table", table_pose, size=(0.8, 1.0, 0.02))

        # Add an object on the table
        object_pose = copy.deepcopy(table_pose)
        object_pose.pose.position.z += 0.1  # 10cm above table

        self.scene.add_box("object", object_pose, size=(0.05, 0.05, 0.1))

    def move_to_pick_pose(self):
        """
        Example: Move to a pick pose above an object
        """
        # Define a pick pose (above the object)
        pick_pose = Pose()
        pick_pose.position.x = 0.5
        pick_pose.position.y = 0.0
        pick_pose.position.z = 0.2  # 20cm above table
        pick_pose.orientation = tf_trans.quaternion_from_euler(0, 3.14159, 0)

        # Plan and execute
        plan = self.plan_to_pose_goal(pick_pose)
        if plan:
            rospy.loginfo("Successfully planned to pick pose")
            # self.execute_plan(plan)  # Uncomment to execute
        else:
            rospy.logwarn("Failed to plan to pick pose")

# ROS 2 version would use different interfaces
def ros2_moveit_example():
    """
    Example of MoveIt usage in ROS 2 context
    """
    import moveit_commander

    # Initialize MoveIt commander
    robot = moveit_commander.RobotCommander()
    scene = moveit_commander.PlanningSceneInterface()
    group = moveit_commander.MoveGroupCommander("manipulator")

    # Get basic information
    print("Robot Groups:", robot.get_group_names())
    print("Current State:", robot.get_current_state())
    print("Reference Frame:", group.get_planning_frame())
    print("End Effector Link:", group.get_end_effector_link())

    # Plan to a joint space goal
    joint_goal = group.get_current_joint_values()
    joint_goal[0] = 0
    joint_goal[1] = -0.785
    joint_goal[2] = 0
    joint_goal[3] = -2.356
    joint_goal[4] = 0
    joint_goal[5] = 1.571
    joint_goal[6] = 0.785

    # Plan and execute
    success = group.go(joint_goal, wait=True)
    group.stop()  # Ensure no residual movement

    print(f"Joint space goal reached: {success}")

    # Plan to a pose goal
    pose_goal = Pose()
    pose_goal.orientation.w = 1.0
    pose_goal.position.x = 0.4
    pose_goal.position.y = 0.0
    pose_goal.position.z = 0.3

    group.set_pose_target(pose_goal)
    success = group.go(wait=True)
    group.stop()
    group.clear_pose_targets()

    print(f"Pose goal reached: {success}")

if __name__ == '__main__':
    # For ROS 1
    if len(sys.argv) > 1 and sys.argv[1] == 'ros1':
        rospy.init_node('moveit_example')
        example = MoveItExample()
        example.add_collision_objects()
        example.move_to_pick_pose()
    # For ROS 2
    else:
        rclpy.init()
        ros2_moveit_example()
        rclpy.shutdown()
```

## Practical Notes

- Always test motion plans in simulation before executing on real robots
- Configure appropriate joint limits and velocity limits for your robot
- Set up proper collision objects in the planning scene
- Use appropriate planning algorithms based on your environment complexity
- Monitor planning time and success rates to optimize performance
- Implement proper error handling for failed planning attempts
- Consider the trade-offs between planning time and trajectory quality

## Summary

MoveIt provides a comprehensive framework for motion planning in robotics, integrating collision detection, kinematics, and trajectory generation into a unified system. Understanding MoveIt's architecture and configuration is essential for implementing effective motion planning in robotic manipulation tasks. The framework enables robots to navigate complex environments while avoiding obstacles and respecting physical constraints.

## Glossary

- **MoveIt**: ROS/ROS 2 motion planning framework for robotics
- **Planning Scene**: Representation of robot state and environment for motion planning
- **Motion Planner**: Algorithm that generates collision-free paths for robots
- **Inverse Kinematics (IK)**: Process of determining joint angles for desired end-effector pose
- **Collision Detection**: System for identifying potential collisions during motion
- **Trajectory**: Time-parameterized path that robot follows during motion
- **Joint Space**: Configuration space defined by robot joint angles
- **Cartesian Space**: 3D space defined by position and orientation
- **Planning Group**: Set of joints that move together as a unit
- **End Effector**: Tool or gripper at the end of a robot arm
- **Collision Object**: Obstacle in the environment that robot must avoid
- **Planning Algorithm**: Method for finding collision-free paths (RRT, PRM, etc.)

## Quick Quiz

1. What is the primary purpose of MoveIt in robotics?
   A) Robot visualization only
   B) Motion planning and manipulation framework
   C) Sensor data processing
   D) Robot hardware control

2. Which of the following is NOT a component of MoveIt's architecture?
   A) Planning Scene
   B) Motion Planners
   C) Collision Detection
   D) Network Protocols

3. What does "inverse kinematics" refer to in the context of MoveIt?
   A) Calculating end-effector pose from joint angles
   B) Calculating joint angles for desired end-effector pose
   C) Detecting collisions
   D) Generating trajectories

4. What is a "planning group" in MoveIt?
   A) A group of robots working together
   B) A set of joints that move together as a unit
   C) A team of roboticists
   D) A category of planning algorithms

5. Which planning algorithm is commonly used in MoveIt?
   A) A* only
   B) Dijkstra only
   C) RRT, RRTConnect, and others
   D) Gradient descent only

**Answers:**
1. B) Motion planning and manipulation framework
2. D) Network Protocols
3. B) Calculating joint angles for desired end-effector pose
4. B) A set of joints that move together as a unit
5. C) RRT, RRTConnect, and others