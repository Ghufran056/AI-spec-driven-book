---
id: 6.4-manipulation-pipeline
title: Manipulation Pipeline
sidebar_label: 6.4 - Manipulation Pipeline
---

# Manipulation Pipeline

## Learning Objectives

By the end of this lesson, you will be able to:
- Understand the complete workflow of a robotic manipulation system
- Identify the key components and their interactions in a manipulation pipeline
- Design and implement a basic manipulation pipeline for simple tasks
- Evaluate the performance and robustness of manipulation systems
- Integrate perception, planning, and control components effectively
- Recognize common failure modes and recovery strategies in manipulation

## Introduction

A robotic manipulation pipeline is a systematic workflow that integrates perception, planning, and control components to enable robots to interact with objects in their environment. The pipeline typically begins with sensing the environment, followed by object recognition and pose estimation, grasp planning, motion planning, and finally execution with feedback control. Each component in the pipeline affects the performance of subsequent components, making the design and integration of these systems critical for successful manipulation.

The manipulation pipeline must handle uncertainty at each stage, from sensor noise in perception to execution errors in control. Modern manipulation systems often include recovery mechanisms and re-planning capabilities to handle failures and adapt to changing conditions. The pipeline needs to operate in real-time while maintaining safety and reliability, especially when interacting with humans or delicate objects.

The design of manipulation pipelines varies depending on the application requirements, robot hardware, and environmental constraints. Some pipelines are highly specialized for specific tasks, while others are designed to be general-purpose and adaptable to various manipulation scenarios. Understanding the flow of information and the dependencies between components is essential for developing robust manipulation systems.

## Main Theory

### 1. Perception-Action Cycle
The fundamental loop in manipulation systems where perception informs action, and action affects the environment which is then perceived again, creating a continuous cycle.

### 2. Sensor Integration
Combining data from multiple sensors (cameras, depth sensors, force/torque sensors) to create a comprehensive understanding of the manipulation scene.

### 3. Task and Motion Planning
Hierarchical planning approach that combines high-level task planning with low-level motion planning for complex manipulation sequences.

### 4. Feedback Control
Continuous monitoring and adjustment of robot actions based on sensor feedback to handle uncertainties and disturbances during manipulation.

### 5. Failure Detection and Recovery
Mechanisms to detect when manipulation attempts fail and implement recovery strategies to continue the task.

### 6. Human-Robot Interaction
Integration of human guidance and collaboration into the manipulation pipeline for shared control scenarios.

```
Complete Manipulation Pipeline:

[Environment] → [Perception] → [Scene Understanding] → [Task Planning] → [Motion Planning] → [Control] → [Action]
      ↑              ↑                  ↑                   ↑                ↑            ↑         ↑
[Objects] ←→ [Sensors] ←→ [Object Models] ←→ [Grasp Planning] ←→ [Trajectory] ←→ [Actuators] ←→ [Effectors]
```

## Examples

### Example: Complete Manipulation Pipeline Implementation
```python
import numpy as np
import time
from typing import List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class ManipulationState(Enum):
    IDLE = "idle"
    PERCEIVING = "perceiving"
    PLANNING = "planning"
    EXECUTING = "executing"
    RECOVERING = "recovering"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class ManipulationGoal:
    """Defines what the manipulation system should achieve"""
    object_name: str
    target_position: np.ndarray
    target_orientation: Optional[np.ndarray] = None
    grasp_type: str = "power"

@dataclass
class ManipulationResult:
    """Result of a manipulation attempt"""
    success: bool
    message: str
    execution_time: float
    grasp_quality: float = 0.0

class PerceptionModule:
    """Handles object detection and pose estimation"""

    def __init__(self):
        self.detected_objects = {}

    def process_sensor_data(self, rgb_image, depth_image):
        """Process sensor data to detect objects"""
        # In practice, this would use computer vision algorithms
        # For this example, we'll simulate object detection

        # Simulate detecting a "red_cube" at a specific position
        detected_objects = {
            "red_cube": {
                "position": np.array([0.5, 0.0, 0.1]),  # meters
                "orientation": np.array([0, 0, 0]),      # Euler angles
                "confidence": 0.95
            },
            "blue_cylinder": {
                "position": np.array([0.6, 0.2, 0.1]),
                "orientation": np.array([0, 0, 0]),
                "confidence": 0.88
            }
        }

        self.detected_objects = detected_objects
        return detected_objects

    def get_object_pose(self, object_name: str) -> Optional[Tuple[np.ndarray, np.ndarray]]:
        """Get the pose of a specific object"""
        if object_name in self.detected_objects:
            obj_data = self.detected_objects[object_name]
            return obj_data["position"], obj_data["orientation"]
        return None

class GraspPlanner:
    """Plans how to grasp objects"""

    def __init__(self):
        self.min_grasp_quality = 0.6

    def plan_grasp(self, object_pose: Tuple[np.ndarray, np.ndarray],
                   object_name: str) -> Optional[dict]:
        """Plan a grasp for the given object"""
        position, orientation = object_pose

        # Simple grasp planning based on object position
        # In practice, this would use more sophisticated algorithms

        # Calculate approach and grasp poses
        approach_offset = np.array([0, 0, 0.1])  # Approach from above
        approach_pose = position + approach_offset

        grasp_pose = position.copy()

        # Calculate grasp quality based on object properties
        grasp_quality = self.estimate_grasp_quality(object_name)

        if grasp_quality >= self.min_grasp_quality:
            return {
                "approach_pose": approach_pose,
                "grasp_pose": grasp_pose,
                "pre_grasp_pose": position + np.array([0, 0, 0.02]),  # 2cm above
                "grasp_quality": grasp_quality,
                "success": True
            }

        return {"success": False, "message": "Low grasp quality"}

    def estimate_grasp_quality(self, object_name: str) -> float:
        """Estimate grasp quality based on object properties"""
        # Simple estimation based on object type
        if "cube" in object_name.lower():
            return 0.8
        elif "cylinder" in object_name.lower():
            return 0.7
        else:
            return 0.6

class MotionPlanner:
    """Plans robot trajectories for manipulation"""

    def __init__(self):
        self.collision_threshold = 0.02  # 2cm clearance

    def plan_trajectory(self, start_pose: np.ndarray,
                       waypoints: List[np.ndarray]) -> Optional[List[np.ndarray]]:
        """Plan a collision-free trajectory through waypoints"""
        # In practice, this would use motion planning algorithms like RRT or PRM

        # For this example, we'll create a simple linear interpolation
        # between waypoints with collision checking
        trajectory = [start_pose]

        for waypoint in waypoints:
            # Simple linear interpolation (in practice, use proper path planning)
            steps = 10
            for i in range(1, steps + 1):
                t = i / steps
                interpolated_pose = start_pose * (1 - t) + waypoint * t
                trajectory.append(interpolated_pose)

            start_pose = waypoint

        # Check for collisions (simplified)
        if self.check_collision_free(trajectory):
            return trajectory
        else:
            return None

    def check_collision_free(self, trajectory: List[np.ndarray]) -> bool:
        """Check if trajectory is collision-free"""
        # Simplified collision checking
        # In practice, this would check against environment geometry
        for pose in trajectory:
            # Check if pose is in valid workspace (simplified)
            if not (-1.0 <= pose[0] <= 1.0 and
                    -1.0 <= pose[1] <= 1.0 and
                    0.0 <= pose[2] <= 1.5):
                return False
        return True

class Controller:
    """Controls robot execution with feedback"""

    def __init__(self):
        self.max_velocity = 0.1  # m/s
        self.max_acceleration = 0.5  # m/s^2
        self.gripper_force_limit = 50.0  # N

    def execute_trajectory(self, trajectory: List[np.ndarray]) -> bool:
        """Execute the planned trajectory"""
        # In practice, this would interface with robot hardware
        # For simulation, we'll just process the trajectory

        success = True
        for i, target_pose in enumerate(trajectory):
            # Simulate movement to target pose
            time.sleep(0.01)  # Simulate execution time

            # Check for execution success (simplified)
            if np.random.random() > 0.99:  # 1% failure rate for demonstration
                success = False
                break

        return success

    def execute_grasp(self, grasp_pose: np.ndarray,
                     grasp_quality: float) -> bool:
        """Execute grasp action"""
        # Simulate grasp execution
        success_probability = min(0.95, grasp_quality + 0.1)  # Add some uncertainty
        return np.random.random() < success_probability

class ManipulationPipeline:
    """Complete manipulation pipeline integrating all components"""

    def __init__(self):
        self.perception = PerceptionModule()
        self.grasp_planner = GraspPlanner()
        self.motion_planner = MotionPlanner()
        self.controller = Controller()
        self.state = ManipulationState.IDLE
        self.current_goal: Optional[ManipulationGoal] = None

    def execute_manipulation(self, goal: ManipulationGoal) -> ManipulationResult:
        """Execute the complete manipulation pipeline"""
        start_time = time.time()
        self.current_goal = goal
        self.state = ManipulationState.PERCEIVING

        try:
            # Step 1: Perception
            print("Step 1: Perception")
            detected_objects = self.perception.process_sensor_data(None, None)

            if goal.object_name not in detected_objects:
                return ManipulationResult(
                    success=False,
                    message=f"Object '{goal.object_name}' not found",
                    execution_time=time.time() - start_time
                )

            # Step 2: Grasp Planning
            print("Step 2: Grasp Planning")
            object_pose = self.perception.get_object_pose(goal.object_name)
            grasp_plan = self.grasp_planner.plan_grasp(object_pose, goal.object_name)

            if not grasp_plan["success"]:
                return ManipulationResult(
                    success=False,
                    message=grasp_plan.get("message", "Grasp planning failed"),
                    execution_time=time.time() - start_time
                )

            # Step 3: Motion Planning
            print("Step 3: Motion Planning")
            current_robot_pose = np.array([0.0, 0.0, 0.5])  # Starting position

            # Define waypoints for the manipulation task
            waypoints = [
                grasp_plan["approach_pose"],
                grasp_plan["pre_grasp_pose"],
                grasp_plan["grasp_pose"]
            ]

            trajectory = self.motion_planner.plan_trajectory(current_robot_pose, waypoints)

            if trajectory is None:
                return ManipulationResult(
                    success=False,
                    message="Motion planning failed - no collision-free path found",
                    execution_time=time.time() - start_time
                )

            # Step 4: Execution
            print("Step 4: Execution")
            self.state = ManipulationState.EXECUTING

            # Execute the approach trajectory
            if not self.controller.execute_trajectory(trajectory[:-1]):  # All but grasp pose
                return ManipulationResult(
                    success=False,
                    message="Trajectory execution failed during approach",
                    execution_time=time.time() - start_time
                )

            # Execute the grasp
            grasp_success = self.controller.execute_grasp(
                grasp_plan["grasp_pose"],
                grasp_plan["grasp_quality"]
            )

            if not grasp_success:
                return ManipulationResult(
                    success=False,
                    message="Grasp execution failed",
                    execution_time=time.time() - start_time,
                    grasp_quality=grasp_plan["grasp_quality"]
                )

            # If we reach here, manipulation was successful
            self.state = ManipulationState.COMPLETED
            return ManipulationResult(
                success=True,
                message="Manipulation completed successfully",
                execution_time=time.time() - start_time,
                grasp_quality=grasp_plan["grasp_quality"]
            )

        except Exception as e:
            self.state = ManipulationState.FAILED
            return ManipulationResult(
                success=False,
                message=f"Manipulation failed with error: {str(e)}",
                execution_time=time.time() - start_time
            )

# Example usage
def pipeline_example():
    pipeline = ManipulationPipeline()

    # Define a manipulation goal
    goal = ManipulationGoal(
        object_name="red_cube",
        target_position=np.array([0.7, 0.3, 0.1]),
        grasp_type="power"
    )

    # Execute the manipulation
    result = pipeline.execute_manipulation(goal)

    print(f"\nManipulation Result:")
    print(f"  Success: {result.success}")
    print(f"  Message: {result.message}")
    print(f"  Time: {result.execution_time:.3f}s")
    print(f"  Grasp Quality: {result.grasp_quality:.3f}")

if __name__ == "__main__":
    pipeline_example()
```

### Example: Error Handling and Recovery in Manipulation
```python
import numpy as np
import time
from enum import Enum
from typing import List, Optional

class RecoveryStrategy(Enum):
    RETRY = "retry"
    REGRASP = "regrasp"
    REPLAN = "replan"
    ABORT = "abort"

class RecoveryManager:
    """Manages error recovery in manipulation pipeline"""

    def __init__(self):
        self.max_retries = 3
        self.current_attempts = 0
        self.failure_history = []

    def handle_failure(self, failure_type: str, context: dict) -> RecoveryStrategy:
        """Determine recovery strategy based on failure type and context"""
        self.failure_history.append({
            'type': failure_type,
            'time': time.time(),
            'context': context
        })

        self.current_attempts += 1

        # Different recovery strategies based on failure type
        if failure_type == "grasp_failure":
            if self.current_attempts <= 2:
                return RecoveryStrategy.REGRASP  # Try different grasp
            else:
                return RecoveryStrategy.REPLAN  # Plan different approach

        elif failure_type == "motion_failure":
            if self.current_attempts <= 1:
                return RecoveryStrategy.REPLAN  # Try different path
            else:
                return RecoveryStrategy.ABORT

        elif failure_type == "perception_failure":
            if self.current_attempts <= 2:
                return RecoveryStrategy.RETRY  # Retake sensor data
            else:
                return RecoveryStrategy.ABORT

        else:
            if self.current_attempts <= self.max_retries:
                return RecoveryStrategy.RETRY
            else:
                return RecoveryStrategy.ABORT

    def reset(self):
        """Reset recovery manager for new task"""
        self.current_attempts = 0
        self.failure_history = []

class RobustManipulationPipeline:
    """Manipulation pipeline with error handling and recovery"""

    def __init__(self):
        self.perception = PerceptionModule()
        self.grasp_planner = GraspPlanner()
        self.motion_planner = MotionPlanner()
        self.controller = Controller()
        self.recovery_manager = RecoveryManager()
        self.max_recovery_attempts = 3

    def execute_with_recovery(self, goal):
        """Execute manipulation with automatic recovery from failures"""
        attempt_count = 0

        while attempt_count < self.max_recovery_attempts:
            print(f"\nAttempt {attempt_count + 1} of {self.max_recovery_attempts}")

            result = self._execute_single_attempt(goal)

            if result.success:
                return result

            print(f"Attempt failed: {result.message}")

            # Determine recovery strategy
            recovery_strategy = self.recovery_manager.handle_failure(
                "general_failure",
                {"attempt": attempt_count, "result": result}
            )

            print(f"Recovery strategy: {recovery_strategy.value}")

            if recovery_strategy == RecoveryStrategy.ABORT:
                return ManipulationResult(
                    success=False,
                    message=f"Manipulation failed after {attempt_count + 1} attempts",
                    execution_time=result.execution_time
                )

            # Apply recovery strategy
            if recovery_strategy == RecoveryStrategy.RETRY:
                print("Retrying same approach...")
                time.sleep(0.5)  # Brief pause before retry
            elif recovery_strategy == RecoveryStrategy.REGRASP:
                print("Planning new grasp...")
                # In a real system, this would involve new grasp planning
                pass
            elif recovery_strategy == RecoveryStrategy.REPLAN:
                print("Replanning entire approach...")
                # In a real system, this would involve complete replanning
                pass

            attempt_count += 1

        return ManipulationResult(
            success=False,
            message=f"Manipulation failed after {self.max_recovery_attempts} recovery attempts",
            execution_time=time.time() - time.time()  # Placeholder for actual time
        )

    def _execute_single_attempt(self, goal):
        """Execute a single manipulation attempt"""
        # This would contain the same logic as the basic pipeline
        # but is simplified here for brevity
        start_time = time.time()

        # Simulate potential failure
        if np.random.random() < 0.3:  # 30% failure rate for demonstration
            return ManipulationResult(
                success=False,
                message="Simulated failure in single attempt",
                execution_time=time.time() - start_time
            )

        # Simulate success
        return ManipulationResult(
            success=True,
            message="Success in single attempt",
            execution_time=time.time() - start_time
        )

# Example with recovery
def recovery_example():
    pipeline = RobustManipulationPipeline()

    goal = ManipulationGoal(
        object_name="red_cube",
        target_position=np.array([0.7, 0.3, 0.1])
    )

    result = pipeline.execute_with_recovery(goal)
    print(f"\nFinal result: {result.message}")
    print(f"Success: {result.success}")

if __name__ == "__main__":
    recovery_example()
```

### Example: Integration with ROS/ROS 2
```python
# This would typically be implemented as a ROS 2 node
# For demonstration, we'll show the conceptual structure

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, PointCloud2
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import String
from manipulation_msgs.msg import ManipulationGoal, ManipulationResult

class ManipulationPipelineROS(Node):
    """ROS 2 node implementing the manipulation pipeline"""

    def __init__(self):
        super().__init__('manipulation_pipeline')

        # Create subscribers for sensor data
        self.image_sub = self.create_subscription(
            Image,
            '/camera/rgb/image_raw',
            self.image_callback,
            10
        )

        self.depth_sub = self.create_subscription(
            Image,
            '/camera/depth/image_raw',
            self.depth_callback,
            10
        )

        self.pointcloud_sub = self.create_subscription(
            PointCloud2,
            '/camera/depth/color/points',
            self.pointcloud_callback,
            10
        )

        # Create publishers for results
        self.result_pub = self.create_publisher(
            ManipulationResult,
            '/manipulation/result',
            10
        )

        self.status_pub = self.create_publisher(
            String,
            '/manipulation/status',
            10
        )

        # Create action server for manipulation goals
        # This would use the ROS 2 action interface
        self.current_goal = None

        # Initialize internal pipeline components
        self.pipeline = ManipulationPipeline()

        # Timer for processing loop
        self.processing_timer = self.create_timer(0.1, self.process_callback)

        self.get_logger().info('Manipulation Pipeline node initialized')

    def image_callback(self, msg):
        """Handle incoming RGB image data"""
        # Process image and update internal state
        self.get_logger().debug('Received RGB image')

    def depth_callback(self, msg):
        """Handle incoming depth image data"""
        self.get_logger().debug('Received depth image')

    def pointcloud_callback(self, msg):
        """Handle incoming point cloud data"""
        self.get_logger().debug('Received point cloud')

    def process_callback(self):
        """Main processing loop"""
        # This would contain the main pipeline logic
        # checking for new goals, processing data, etc.
        pass

def ros_main():
    """Main function to run the ROS manipulation pipeline"""
    rclpy.init()
    manipulation_node = ManipulationPipelineROS()

    try:
        rclpy.spin(manipulation_node)
    except KeyboardInterrupt:
        pass
    finally:
        manipulation_node.destroy_node()
        rclpy.shutdown()

# The actual ROS implementation would be more complex
# and involve action servers, service calls, and proper
# integration with robot hardware interfaces
```

## Practical Notes

- Implement robust error handling and recovery mechanisms
- Consider real-time performance requirements for each pipeline component
- Validate pipeline components individually before integration
- Test pipeline under various environmental conditions
- Monitor and log pipeline performance for debugging
- Plan for graceful degradation when components fail
- Consider human oversight and intervention capabilities

## Summary

The manipulation pipeline integrates perception, planning, and control components into a cohesive system for robotic manipulation. Success requires careful design of each component and their interactions, with particular attention to error handling and recovery. Modern manipulation systems must operate reliably in uncertain environments while maintaining safety and efficiency. The pipeline serves as the foundation for complex robotic manipulation tasks in various applications.

## Glossary

- **Manipulation Pipeline**: Integrated system of perception, planning, and control for robot manipulation
- **Perception-Action Cycle**: Continuous loop where perception informs action and action affects perception
- **Task Planning**: High-level planning of manipulation sequence and subtasks
- **Motion Planning**: Low-level planning of robot trajectories and movements
- **Grasp Planning**: Determining how to grasp objects effectively
- **Feedback Control**: Continuous adjustment of robot actions based on sensor feedback
- **Recovery Strategy**: Plan for handling and recovering from manipulation failures
- **Collision Checking**: Verifying robot trajectories don't collide with obstacles
- **Grasp Quality**: Metric for evaluating the stability of a grasp
- **Force Control**: Controlling the forces applied during manipulation
- **Impedance Control**: Controlling robot's mechanical impedance during interaction
- **Shared Control**: Human-robot collaboration in manipulation tasks

## Quick Quiz

1. What are the three main components of a manipulation pipeline?
   A) Perception, Planning, Control
   B) Sensing, Actuation, Communication
   C) Detection, Grasping, Moving
   D) Vision, Mechanics, Electronics

2. What is the purpose of a perception-action cycle in manipulation?
   A) To reduce computational requirements
   B) To create a continuous loop where perception informs action and action affects the environment
   C) To increase robot speed
   D) To reduce sensor requirements

3. Which of the following is NOT a typical component of a manipulation pipeline?
   A) Perception module
   B) Motion planning module
   C) Task planning module
   D) Network routing module

4. What is the main purpose of recovery strategies in manipulation systems?
   A) To increase manipulation speed
   B) To handle failures and continue tasks when possible
   C) To reduce computational load
   D) To improve sensor accuracy

5. What does "grasp quality" refer to in manipulation systems?
   A) The visual appearance of the grasp
   B) A metric for evaluating the stability and effectiveness of a grasp
   C) The type of gripper used
   D) The speed of the grasp

**Answers:**
1. A) Perception, Planning, Control
2. B) To create a continuous loop where perception informs action and action affects the environment
3. D) Network routing module
4. B) To handle failures and continue tasks when possible
5. B) A metric for evaluating the stability and effectiveness of a grasp