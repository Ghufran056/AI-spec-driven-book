---
id: 6.1-types-of-robotic-arms-hands
title: Types of Robotic Arms & Hands
sidebar_label: 6.1 - Types of Robotic Arms & Hands
---

# Types of Robotic Arms & Hands

## Learning Objectives

By the end of this lesson, you will be able to:
- Identify and classify different types of robotic arms based on their kinematic structure
- Understand the design principles and applications of various robotic hand configurations
- Compare the advantages and limitations of different arm and hand types
- Recognize the relationship between arm kinematics and workspace capabilities
- Understand the integration of robotic arms and hands for manipulation tasks
- Evaluate selection criteria for robotic arms and hands in specific applications

## Introduction

Robotic arms and hands are fundamental components of robotic manipulation systems, designed to perform tasks that require reaching, grasping, manipulating, and interacting with objects in the environment. These systems come in various configurations, each optimized for specific applications, workspaces, and performance requirements. Understanding the different types of robotic arms and hands is crucial for selecting the appropriate hardware for specific manipulation tasks and for developing effective control and planning algorithms.

Robotic arms are typically classified by their kinematic structure, which determines their degrees of freedom, workspace, and motion capabilities. The most common configuration is the serial manipulator with 6 degrees of freedom, which provides position and orientation control in 3D space. However, specialized applications may require different configurations, such as redundant manipulators with more than 6 degrees of freedom, parallel manipulators for high precision, or collaborative robots (cobots) designed for safe human-robot interaction.

Robotic hands, or end-effectors, are equally diverse in design, ranging from simple two-finger grippers to anthropomorphic hands with multiple degrees of freedom that can perform complex manipulation tasks. The choice of hand depends on the required grasping force, dexterity, precision, and adaptability to different object shapes and sizes. Understanding these options and their trade-offs is essential for successful manipulation system design.

## Main Theory

### 1. Serial Manipulator Configurations
Serial manipulators consist of links connected by joints in a chain configuration, with the most common being articulated (6-axis), SCARA (Selective Compliance Assembly Robot Arm), and Cartesian (3-axis) robots.

### 2. Parallel Manipulators
Parallel manipulators have multiple kinematic chains connecting the base to the end-effector, providing high stiffness and precision but typically with a smaller workspace.

### 3. Redundant Manipulators
Robots with more than 6 degrees of freedom offer additional flexibility for obstacle avoidance and optimization of secondary objectives like joint limits or manipulability.

### 4. Anthropomorphic Hands
Multi-fingered hands designed to mimic human hand structure and capabilities, offering high dexterity for complex manipulation tasks.

### 5. Specialized End-Effectors
Purpose-built grippers and tools designed for specific applications such as suction cups, magnetic grippers, or custom tooling.

### 6. Collaborative Robot Arms
Designed for safe interaction with humans, featuring force limitation, collision detection, and ease of programming.

```
Robotic Arm Classification:

[Serial Arms]        [Parallel Arms]      [Redundant Arms]
   ↑                    ↑                    ↑
[Articulated] ←→ [Delta Robot] ←→ [7+ DOF Arms]
[SCARA]          [Stewart Platform]   [8 DOF Arms]
[Cartesian]                           [10+ DOF Arms]
```

## Examples

### Example: Common Robotic Arm Configurations
```python
import numpy as np
from dataclasses import dataclass
from typing import List, Tuple

@dataclass
class RobotArmConfiguration:
    """Represents different types of robotic arm configurations"""

    name: str
    dof: int
    joint_types: List[str]  # 'R' for revolute, 'P' for prismatic
    workspace_shape: str
    primary_application: str
    reach: float  # in meters
    payload: float  # in kg

# Different types of robotic arms
articulated_arm = RobotArmConfiguration(
    name="Articulated Arm",
    dof=6,
    joint_types=['R', 'R', 'R', 'R', 'R', 'R'],  # 6 revolute joints
    workspace_shape="Spherical",
    primary_application="General purpose manipulation",
    reach=1.5,
    payload=5.0
)

scara_arm = RobotArmConfiguration(
    name="SCARA Arm",
    dof=4,
    joint_types=['R', 'R', 'P', 'R'],  # 2 revolute, 1 prismatic, 1 revolute
    workspace_shape="Cylindrical",
    primary_application="Assembly and pick-and-place",
    reach=0.8,
    payload=3.0
)

cartesian_arm = RobotArmConfiguration(
    name="Cartesian Arm",
    dof=3,
    joint_types=['P', 'P', 'P'],  # 3 prismatic joints
    workspace_shape="Rectangular",
    primary_application="3D printing, CNC",
    reach=1.0,  # diagonal reach
    payload=10.0
)

delta_robot = RobotArmConfiguration(
    name="Delta Robot",
    dof=3,
    joint_types=['R', 'R', 'R'],  # 3 revolute joints in parallel structure
    workspace_shape="Conical",
    primary_application="High-speed pick-and-place",
    reach=1.2,
    payload=1.0
)

# Print arm characteristics
print("Robotic Arm Configurations:")
for arm in [articulated_arm, scara_arm, cartesian_arm, delta_robot]:
    print(f"  {arm.name}: {arm.dof} DOF, {arm.joint_types}, {arm.workspace_shape} workspace")
```

### Example: Robotic Hand Types and Grasping Strategies
```python
from enum import Enum
from dataclasses import dataclass
from typing import List

class HandType(Enum):
    TWO_FINGER = "Two-Finger Gripper"
    SUCTION_CUP = "Suction Cup"
    ANTHROPOMORPHIC = "Anthropomorphic Hand"
    PARALLEL_GRIPPER = "Parallel Jaw Gripper"
    CUSTOM_TOOL = "Custom Tool"

class GraspType(Enum):
    POWER_GRASP = "Power Grasp - Cylindrical objects"
    PINCH_GRASP = "Pinch Grasp - Small objects"
    LATERAL_GRASP = "Lateral Grasp - Flat objects"
    SUCTION_GRASP = "Suction - Smooth surfaces"

@dataclass
class RoboticHand:
    name: str
    hand_type: HandType
    dof: int
    max_force: float  # in Newtons
    grasp_types: List[GraspType]
    finger_count: int
    adaptability: str  # "High", "Medium", "Low"

# Different types of robotic hands
grippers = [
    RoboticHand(
        name="Parallel Jaw Gripper",
        hand_type=HandType.PARALLEL_GRIPPER,
        dof=1,  # Single actuator for jaw opening/closing
        max_force=200.0,
        grasp_types=[GraspType.POWER_GRASP, GraspType.LATERAL_GRASP],
        finger_count=2,
        adaptability="Medium"
    ),
    RoboticHand(
        name="Three-Finger Gripper",
        hand_type=HandType.ANTHROPOMORPHIC,
        dof=9,  # 3 fingers × 3 joints each
        max_force=50.0,
        grasp_types=[GraspType.POWER_GRASP, GraspType.PINCH_GRASP],
        finger_count=3,
        adaptability="High"
    ),
    RoboticHand(
        name="Suction Cup",
        hand_type=HandType.SUCTION_CUP,
        dof=0,  # Passive adaptation
        max_force=100.0,  # Adhesion force
        grasp_types=[GraspType.SUCTION_GRASP],
        finger_count=0,
        adaptability="Low"
    ),
    RoboticHand(
        name="Anthropomorphic Hand",
        hand_type=HandType.ANTHROPOMORPHIC,
        dof=20,  # Multiple joints per finger
        max_force=30.0,
        grasp_types=[GraspType.POWER_GRASP, GraspType.PINCH_GRASP, GraspType.LATERAL_GRASP],
        finger_count=5,
        adaptability="High"
    )
]

# Display hand characteristics
print("Robotic Hand Types:")
for hand in grippers:
    print(f"  {hand.name}: {hand.dof} DOF, {hand.finger_count} fingers, {hand.adaptability} adaptability")
    print(f"    Capable of: {[g.value.split(' - ')[0] for g in hand.grasp_types]}")
```

### Example: Kinematic Analysis of Different Arm Types
```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class KinematicAnalyzer:
    """Analyzes workspace and capabilities of different robotic arm types"""

    @staticmethod
    def forward_kinematics_6dof(joint_angles: List[float]) -> Tuple[np.ndarray, np.ndarray]:
        """
        Simplified forward kinematics for 6-DOF articulated robot
        Returns (position, orientation) of end-effector
        """
        # This is a simplified representation - real implementation would use DH parameters
        theta = np.array(joint_angles)

        # Calculate position based on simplified kinematic model
        # (In practice, use Denavit-Hartenberg parameters or other methods)
        pos = np.zeros(3)
        pos[0] = np.cos(theta[0]) * (0.5 + 0.4*np.cos(theta[1]) + 0.3*np.cos(theta[1]+theta[2]))
        pos[1] = np.sin(theta[0]) * (0.5 + 0.4*np.cos(theta[1]) + 0.3*np.cos(theta[1]+theta[2]))
        pos[2] = 0.1 + 0.4*np.sin(theta[1]) + 0.3*np.sin(theta[1]+theta[2])

        # Calculate orientation using ZYZ Euler angles
        rot = R.from_euler('xyz', theta[3:6]).as_matrix()

        return pos, rot

    @staticmethod
    def calculate_workspace_volume(link_lengths: List[float]) -> float:
        """Calculate approximate workspace volume for articulated arm"""
        # For a 6-DOF arm with given link lengths
        total_reach = sum(link_lengths)

        # Approximate as sphere with radius = total_reach
        volume = (4/3) * np.pi * (total_reach ** 3)

        return volume

    @staticmethod
    def is_in_workspace(target_pos: np.ndarray, link_lengths: List[float]) -> bool:
        """Check if a target position is reachable by the arm"""
        total_reach = sum(link_lengths)
        target_distance = np.linalg.norm(target_pos)

        # Simple check: if distance to target is less than total reach
        return target_distance <= total_reach

# Example analysis
analyzer = KinematicAnalyzer()

# Example for a 6-DOF arm
link_lengths = [0.1, 0.5, 0.4, 0.3, 0.2, 0.1]  # Link lengths in meters
workspace_volume = analyzer.calculate_workspace_volume(link_lengths)
print(f"Approximate workspace volume: {workspace_volume:.2f} m³")

# Test if a point is reachable
test_point = np.array([0.8, 0.0, 0.5])  # meters
reachable = analyzer.is_in_workspace(test_point, link_lengths)
print(f"Point {test_point} reachable: {reachable}")

# Calculate end-effector pose for specific joint angles
joint_angles = [0.0, np.pi/4, -np.pi/4, 0.0, 0.0, 0.0]  # radians
position, orientation = analyzer.forward_kinematics_6dof(joint_angles)
print(f"End-effector pose: position={position}, orientation={orientation[:3, :3]}")
```

## Practical Notes

- Consider payload capacity when selecting robotic arms for specific tasks
- Evaluate workspace requirements against actual arm capabilities
- Factor in accuracy and repeatability requirements for precision tasks
- Consider integration requirements with existing systems and safety standards
- Plan for maintenance access and end-effector changes
- Account for environmental conditions (temperature, humidity, cleanliness)
- Consider cost implications including initial purchase and operational costs

## Summary

Robotic arms and hands come in various configurations optimized for different applications and requirements. Understanding the kinematic structure, workspace characteristics, and capabilities of different types is essential for selecting appropriate hardware and developing effective manipulation systems. The choice of arm and hand significantly impacts the system's performance, cost, and application suitability.

## Glossary

- **DOF**: Degrees of Freedom - independent movements a robot can make
- **Serial Manipulator**: Robot arm with joints connected in a chain configuration
- **Parallel Manipulator**: Robot with multiple kinematic chains connecting base to end-effector
- **Workspace**: Volume of space a robot's end-effector can reach
- **Payload**: Maximum weight a robot can carry while maintaining performance
- **End-Effector**: Device at the end of a robot arm that interacts with the environment
- **Forward Kinematics**: Calculating end-effector position from joint angles
- **Inverse Kinematics**: Calculating required joint angles to achieve desired position
- **Redundant Manipulator**: Robot with more DOF than required for task
- **Collaborative Robot**: Robot designed for safe human-robot interaction
- **SCARA**: Selective Compliance Assembly Robot Arm - has compliance in horizontal plane
- **Anthropomorphic**: Robot hand designed to mimic human hand structure

## Quick Quiz

1. What does "DOF" stand for in robotics?
   A) Dynamic Operating Force
   B) Degrees of Freedom
   C) Differential Operating Function
   D) Digital Output Feedback

2. Which type of robot arm is best suited for assembly tasks requiring high-speed pick-and-place operations?
   A) Cartesian robot
   B) SCARA robot
   C) 6-axis articulated robot
   D) Delta robot

3. What is the primary advantage of a parallel manipulator compared to a serial manipulator?
   A) Larger workspace
   B) Higher stiffness and precision
   C) Lower cost
   D) More degrees of freedom

4. Which of the following is NOT a common type of robotic hand?
   A) Parallel jaw gripper
   B) Suction cup
   C) Three-finger gripper
   D) Linear actuator

5. What characterizes a redundant manipulator?
   A) Fewer degrees of freedom than required
   B) More degrees of freedom than required for the task
   C) Parallel kinematic structure
   D) Fixed base mounting

**Answers:**
1. B) Degrees of Freedom
2. D) Delta robot
3. B) Higher stiffness and precision
4. D) Linear actuator
5. B) More degrees of freedom than required for the task