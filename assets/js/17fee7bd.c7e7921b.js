"use strict";(globalThis.webpackChunkai_driven_book=globalThis.webpackChunkai_driven_book||[]).push([[2986],{7951:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapter6/6.5-moveit-motion-planning-basics","title":"MoveIt Motion Planning Basics","description":"Learning Objectives","source":"@site/docs/chapter6/6.5-moveit-motion-planning-basics.mdx","sourceDirName":"chapter6","slug":"/chapter6/6.5-moveit-motion-planning-basics","permalink":"/AI-spec-driven-book/docs/chapter6/6.5-moveit-motion-planning-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter6/6.5-moveit-motion-planning-basics.mdx","tags":[],"version":"current","frontMatter":{"id":"6.5-moveit-motion-planning-basics","title":"MoveIt Motion Planning Basics","sidebar_label":"6.5 - MoveIt Motion Planning Basics"},"sidebar":"tutorialSidebar","previous":{"title":"6.4 - Manipulation Pipeline","permalink":"/AI-spec-driven-book/docs/chapter6/6.4-manipulation-pipeline"},"next":{"title":"6.6 - Fine Manipulation & Dexterity","permalink":"/AI-spec-driven-book/docs/chapter6/6.6-fine-manipulation-dexterity"}}');var i=o(4848),a=o(8453);const r={id:"6.5-moveit-motion-planning-basics",title:"MoveIt Motion Planning Basics",sidebar_label:"6.5 - MoveIt Motion Planning Basics"},s="MoveIt Motion Planning Basics",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Main Theory",id:"main-theory",level:2},{value:"1. MoveIt Architecture",id:"1-moveit-architecture",level:3},{value:"2. Planning Scene Representation",id:"2-planning-scene-representation",level:3},{value:"3. Motion Planning Algorithms",id:"3-motion-planning-algorithms",level:3},{value:"4. Inverse Kinematics Integration",id:"4-inverse-kinematics-integration",level:3},{value:"5. Collision Detection and Avoidance",id:"5-collision-detection-and-avoidance",level:3},{value:"6. Trajectory Generation and Execution",id:"6-trajectory-generation-and-execution",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: MoveIt Configuration Files",id:"example-moveit-configuration-files",level:3},{value:"Example: Basic MoveIt Motion Planning Node",id:"example-basic-moveit-motion-planning-node",level:3},{value:"Example: MoveIt Python Interface Usage",id:"example-moveit-python-interface-usage",level:3},{value:"Practical Notes",id:"practical-notes",level:2},{value:"Summary",id:"summary",level:2},{value:"Glossary",id:"glossary",level:2},{value:"Quick Quiz",id:"quick-quiz",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"moveit-motion-planning-basics",children:"MoveIt Motion Planning Basics"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand the fundamental concepts and architecture of the MoveIt framework"}),"\n",(0,i.jsx)(e.li,{children:"Configure and use MoveIt for basic motion planning tasks"}),"\n",(0,i.jsx)(e.li,{children:"Set up MoveIt for a custom robotic arm configuration"}),"\n",(0,i.jsx)(e.li,{children:"Implement motion planning with collision avoidance"}),"\n",(0,i.jsx)(e.li,{children:"Use MoveIt's planning interfaces and visualization tools"}),"\n",(0,i.jsx)(e.li,{children:"Integrate MoveIt with ROS/ROS 2 manipulation pipelines"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt is the de facto standard motion planning framework for ROS and ROS 2, providing a comprehensive set of tools and libraries for robotic manipulation and motion planning. It integrates state-of-the-art motion planning algorithms, collision detection, kinematic solvers, and trajectory execution into a unified framework that enables robots to plan and execute complex motions while avoiding obstacles and respecting joint limits. MoveIt has become essential for robotic manipulation research and applications, offering both high-level planning capabilities and low-level control interfaces."}),"\n",(0,i.jsx)(e.p,{children:"The framework provides a modular architecture that allows users to customize different components based on their specific requirements. It includes support for various planning algorithms such as RRT, RRTConnect, and CHOMP, as well as integration with physics simulators like Gazebo and real robot hardware. MoveIt's flexibility and extensive documentation have made it the go-to solution for motion planning in the robotics community."}),"\n",(0,i.jsx)(e.p,{children:"MoveIt handles many of the complex aspects of motion planning automatically, including inverse kinematics, collision checking, and trajectory generation. However, understanding its architecture and configuration is crucial for effective use, especially when working with custom robot configurations or specialized applications. The framework also provides extensive visualization tools through RViz that help users debug and understand the planning process."}),"\n",(0,i.jsx)(e.h2,{id:"main-theory",children:"Main Theory"}),"\n",(0,i.jsx)(e.h3,{id:"1-moveit-architecture",children:"1. MoveIt Architecture"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt's architecture consists of multiple interconnected components including the planning scene, motion planners, collision detection, kinematic solvers, and trajectory execution modules that work together to enable motion planning."}),"\n",(0,i.jsx)(e.h3,{id:"2-planning-scene-representation",children:"2. Planning Scene Representation"}),"\n",(0,i.jsx)(e.p,{children:"The planning scene maintains the robot state and the environment, including static and dynamic obstacles, allowing the planner to generate collision-free trajectories."}),"\n",(0,i.jsx)(e.h3,{id:"3-motion-planning-algorithms",children:"3. Motion Planning Algorithms"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt supports various motion planning algorithms such as RRT, RRTConnect, LazyPRM, and TrajOpt, each with different characteristics for different types of planning problems."}),"\n",(0,i.jsx)(e.h3,{id:"4-inverse-kinematics-integration",children:"4. Inverse Kinematics Integration"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt integrates with various IK solvers to efficiently compute joint configurations for desired end-effector poses, supporting both analytical and numerical approaches."}),"\n",(0,i.jsx)(e.h3,{id:"5-collision-detection-and-avoidance",children:"5. Collision Detection and Avoidance"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt uses FCL (Flexible Collision Library) and Bullet for efficient collision detection, enabling safe motion planning in complex environments."}),"\n",(0,i.jsx)(e.h3,{id:"6-trajectory-generation-and-execution",children:"6. Trajectory Generation and Execution"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt generates smooth, executable trajectories and provides interfaces for executing them on real or simulated robots."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"MoveIt Architecture:\n\n[Planning Request] \u2192 [Planning Scene] \u2192 [Motion Planner] \u2192 [Trajectory] \u2192 [Execution]\n      \u2191                   \u2191                  \u2191              \u2191           \u2191\n[User Interface] \u2190\u2192 [Collision Checking] \u2190\u2192 [IK Solver] \u2190\u2192 [Filters] \u2190\u2192 [Controllers]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(e.h3,{id:"example-moveit-configuration-files",children:"Example: MoveIt Configuration Files"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:"\x3c!-- config/joint_limits.yaml --\x3e\n# Joint limit definitions for MoveIt\njoint_limits:\n  joint1:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n  joint2:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n  joint3:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n  joint4:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n  joint5:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n  joint6:\n    has_velocity_limits: true\n    max_velocity: 1.0\n    has_acceleration_limits: true\n    max_acceleration: 0.5\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"# config/kinematics.yaml\n# Kinematic solver configuration for MoveIt\nmanipulator:\n  kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin\n  kinematics_solver_search_resolution: 0.005\n  kinematics_solver_timeout: 0.005\n  kinematics_solver_attempts: 3\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"# config/ompl_planning.yaml\n# OMPL planning configuration for MoveIt\nplanner_configs:\n  SBLkConfigDefault:\n    type: geometric::SBL\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n  ESTkConfigDefault:\n    type: geometric::EST\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    goal_bias: 0.05  # When close to goal select goal, def: 0.05\n  LBKPIECEkConfigDefault:\n    type: geometric::LBKPIECE\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9\n    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5\n  BKPIECEkConfigDefault:\n    type: geometric::BKPIECE\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9 (0.5)\n    failed_expansion_score_factor: 0.5  # When to disregard type, def: 0.5\n    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5\n  KPIECEkConfigDefault:\n    type: geometric::KPIECE\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    goal_bias: 0.05  # When close to goal select goal, def: 0.05\n    border_fraction: 0.9  # Fraction of time focused on boarder default: 0.9 (0.5)\n    failed_expansion_score_factor: 0.5  # When to disregard type, def: 0.5\n    min_valid_path_fraction: 0.5  # Accept partially valid moves above fraction, def: 0.5\n  RRTkConfigDefault:\n    type: geometric::RRT\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    goal_bias: 0.05  # When close to goal select goal, def: 0.05\n  RRTConnectkConfigDefault:\n    type: geometric::RRTConnect\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n  RRTstarkConfigDefault:\n    type: geometric::RRTstar\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    goal_bias: 0.05  # When close to goal select goal, def: 0.05\n    delay_collision_checking: 1  # Stop collision checking after a delay, def: 1\n  TRRTkConfigDefault:\n    type: geometric::TRRT\n    range: 0.0  # Max motion added to tree, default: 0.0 (0.2)\n    goal_bias: 0.05  # When close to goal select goal, def: 0.05\n    max_states_failed: 10  # When to start increasing temp, def: 10\n    temp_change_factor: 2.0  # How much to increase or decrease temp, def: 2.0\n    min_temperature: 10e-10  # Lower limit of temp change, def: 10e-10\n    init_temperature: 10e-6  # Initial temperature, def: 10e-6\n    frountier_threshold: 0.0  # Dist new state to nearest free in tree, def: 0.0 (0.2)\n    frountierNodeRatio: 0.1  # Near frontier bias, def: 0.1 (0.0)\n    k_constant: 1.0  # Value used to normalize expresssion, def: 1.0 (0.0)\n\nmanipulator:\n  planner_configs:\n    - SBLkConfigDefault\n    - ESTkConfigDefault\n    - LBKPIECEkConfigDefault\n    - BKPIECEkConfigDefault\n    - KPIECEkConfigDefault\n    - RRTkConfigDefault\n    - RRTConnectkConfigDefault\n    - RRTstarkConfigDefault\n    - TRRTkConfigDefault\n  projection_evaluator: joints(joint1,joint2)\n  longest_valid_segment_fraction: 0.005\n"})}),"\n",(0,i.jsx)(e.h3,{id:"example-basic-moveit-motion-planning-node",children:"Example: Basic MoveIt Motion Planning Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom moveit_msgs.msg import PlanningScene, PlanningSceneWorld\nfrom moveit_msgs.srv import GetMotionPlan\nfrom moveit_msgs.action import MoveGroup\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory\nfrom builtin_interfaces.msg import Duration\nimport time\n\nclass MoveItMotionPlanner(Node):\n    def __init__(self):\n        super().__init__('moveit_motion_planner')\n\n        # Initialize MoveIt interfaces\n        self.move_group_interface = None  # Would be initialized with actual MoveIt interface\n        self.planning_scene_interface = None  # Would be initialized with actual interface\n\n        # Robot state publisher\n        self.joint_state_publisher = self.create_publisher(\n            JointState,\n            '/joint_states',\n            10\n        )\n\n        # Initialize robot parameters\n        self.robot_name = 'manipulator'\n        self.group_name = 'manipulator'\n\n        self.get_logger().info('MoveIt Motion Planner initialized')\n\n    def plan_to_pose(self, target_pose):\n        \"\"\"\n        Plan motion to a target pose using MoveIt\n        \"\"\"\n        # In a real implementation, this would use the MoveIt Python interface\n        # For this example, we'll outline the general approach:\n\n        # 1. Set the target pose\n        # move_group.set_pose_target(target_pose)\n\n        # 2. Plan the motion\n        # plan = move_group.plan()\n\n        # 3. Execute if successful\n        # move_group.execute(plan, wait=True)\n\n        # For demonstration purposes, we'll return a simulated plan\n        simulated_plan = self.create_simulated_trajectory(target_pose)\n        return simulated_plan\n\n    def plan_to_joint_values(self, joint_values):\n        \"\"\"\n        Plan motion to specific joint values using MoveIt\n        \"\"\"\n        # In a real implementation:\n        # move_group.set_joint_value_target(joint_values)\n        # plan = move_group.plan()\n        # return plan\n\n        # For demonstration:\n        simulated_plan = self.create_simulated_joint_trajectory(joint_values)\n        return simulated_plan\n\n    def add_collision_object(self, object_name, pose, dimensions):\n        \"\"\"\n        Add a collision object to the planning scene\n        \"\"\"\n        # In a real implementation, this would use the PlanningSceneInterface\n        # planning_scene_interface.add_box(object_name, pose, dimensions)\n\n        self.get_logger().info(f'Added collision object: {object_name}')\n\n    def remove_collision_object(self, object_name):\n        \"\"\"\n        Remove a collision object from the planning scene\n        \"\"\"\n        # In a real implementation:\n        # planning_scene_interface.remove_world_object(object_name)\n\n        self.get_logger().info(f'Removed collision object: {object_name}')\n\n    def create_simulated_trajectory(self, target_pose):\n        \"\"\"\n        Create a simulated trajectory for demonstration\n        \"\"\"\n        # This would normally be created by MoveIt's planner\n        # For simulation purposes:\n        trajectory = JointTrajectory()\n        trajectory.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']\n\n        # Create a simple trajectory with a few points\n        for i in range(5):  # 5 trajectory points\n            point = JointTrajectory().points[0] if len(JointTrajectory().points) > 0 else None\n            # In a real implementation, this would contain actual joint values\n            # calculated by MoveIt's inverse kinematics solver\n            pass\n\n        return trajectory\n\n    def create_simulated_joint_trajectory(self, joint_values):\n        \"\"\"\n        Create a simulated joint trajectory for demonstration\n        \"\"\"\n        trajectory = JointTrajectory()\n        trajectory.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']\n\n        # Add trajectory point with target joint values\n        from trajectory_msgs.msg import JointTrajectoryPoint\n        point = JointTrajectoryPoint()\n        point.positions = joint_values\n        point.time_from_start = Duration(sec=2, nanosec=0)  # 2 seconds to reach\n        trajectory.points = [point]\n\n        return trajectory\n\ndef main(args=None):\n    rclpy.init(args=args)\n    motion_planner = MoveItMotionPlanner()\n\n    # Example: Plan to a target pose\n    target_pose = PoseStamped()\n    target_pose.header.frame_id = \"base_link\"\n    target_pose.pose.position.x = 0.5\n    target_pose.pose.position.y = 0.0\n    target_pose.pose.position.z = 0.5\n    target_pose.pose.orientation.w = 1.0\n\n    # Plan and execute\n    plan = motion_planner.plan_to_pose(target_pose)\n    if plan:\n        motion_planner.get_logger().info('Motion plan generated successfully')\n    else:\n        motion_planner.get_logger().info('Failed to generate motion plan')\n\n    # Example: Plan to specific joint values\n    joint_values = [0.0, -1.57, 0.0, -1.57, 0.0, 0.0]\n    joint_plan = motion_planner.plan_to_joint_values(joint_values)\n    if joint_plan:\n        motion_planner.get_logger().info('Joint space plan generated successfully')\n\n    motion_planner.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"example-moveit-python-interface-usage",children:"Example: MoveIt Python Interface Usage"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# moveit_example.py\nimport sys\nimport copy\nimport rospy\nfrom moveit_commander import RobotCommander, PlanningSceneInterface, MoveGroupCommander\nfrom moveit_msgs.msg import RobotState, RobotTrajectory\nfrom geometry_msgs.msg import Pose, PoseStamped\nfrom std_msgs.msg import String\nimport tf.transformations as tf_trans\n\nclass MoveItExample:\n    def __init__(self):\n        # Initialize MoveIt commander\n        self.robot = RobotCommander()\n        self.scene = PlanningSceneInterface()\n        self.group = MoveItCommander("manipulator")  # Replace with your group name\n\n        # Allow some time for initialization\n        rospy.sleep(2)\n\n    def plan_cartesian_path(self, waypoints, eef_step=0.01, jump_threshold=0.0,\n                          avoid_collisions=True):\n        """\n        Plan a Cartesian path through waypoints\n        """\n        # Set the start state to current state\n        self.group.set_start_state_to_current_state()\n\n        # Plan Cartesian path\n        fraction = 0.0\n        for attempts in range(5):  # Try up to 5 times\n            (plan, fraction) = self.group.compute_cartesian_path(\n                waypoints,   # waypoints to follow\n                eef_step,    # eef_step\n                jump_threshold,  # jump_threshold\n                avoid_collisions=avoid_collisions\n            )\n\n            if fraction >= 0.95:  # If 95% of path is valid\n                return plan\n            else:\n                rospy.loginfo(f"Cartesian path planning attempt {attempts+1} achieved {fraction*100}% success")\n\n        rospy.logwarn("Failed to plan Cartesian path with high success rate")\n        return None\n\n    def plan_to_pose_goal(self, target_pose):\n        """\n        Plan motion to a target pose\n        """\n        # Set the pose target\n        self.group.set_pose_target(target_pose)\n\n        # Plan to the target\n        plan = self.group.plan()\n\n        # Clear the target\n        self.group.clear_pose_targets()\n\n        return plan\n\n    def plan_to_joint_goal(self, joint_values):\n        """\n        Plan motion to joint space goal\n        """\n        # Set joint value target\n        self.group.set_joint_value_target(joint_values)\n\n        # Plan to the target\n        plan = self.group.plan()\n\n        # Clear the target\n        self.group.clear_pose_targets()\n\n        return plan\n\n    def execute_plan(self, plan):\n        """\n        Execute a planned trajectory\n        """\n        return self.group.execute(plan, wait=True)\n\n    def add_collision_objects(self):\n        """\n        Add collision objects to the planning scene\n        """\n        # Add a table as a collision object\n        table_pose = PoseStamped()\n        table_pose.header.frame_id = self.robot.get_planning_frame()\n        table_pose.pose.position.x = 0.5\n        table_pose.pose.position.y = 0.0\n        table_pose.pose.position.z = 0.0\n        table_pose.pose.orientation.w = 1.0\n\n        self.scene.add_box("table", table_pose, size=(0.8, 1.0, 0.02))\n\n        # Add an object on the table\n        object_pose = copy.deepcopy(table_pose)\n        object_pose.pose.position.z += 0.1  # 10cm above table\n\n        self.scene.add_box("object", object_pose, size=(0.05, 0.05, 0.1))\n\n    def move_to_pick_pose(self):\n        """\n        Example: Move to a pick pose above an object\n        """\n        # Define a pick pose (above the object)\n        pick_pose = Pose()\n        pick_pose.position.x = 0.5\n        pick_pose.position.y = 0.0\n        pick_pose.position.z = 0.2  # 20cm above table\n        pick_pose.orientation = tf_trans.quaternion_from_euler(0, 3.14159, 0)\n\n        # Plan and execute\n        plan = self.plan_to_pose_goal(pick_pose)\n        if plan:\n            rospy.loginfo("Successfully planned to pick pose")\n            # self.execute_plan(plan)  # Uncomment to execute\n        else:\n            rospy.logwarn("Failed to plan to pick pose")\n\n# ROS 2 version would use different interfaces\ndef ros2_moveit_example():\n    """\n    Example of MoveIt usage in ROS 2 context\n    """\n    import moveit_commander\n\n    # Initialize MoveIt commander\n    robot = moveit_commander.RobotCommander()\n    scene = moveit_commander.PlanningSceneInterface()\n    group = moveit_commander.MoveGroupCommander("manipulator")\n\n    # Get basic information\n    print("Robot Groups:", robot.get_group_names())\n    print("Current State:", robot.get_current_state())\n    print("Reference Frame:", group.get_planning_frame())\n    print("End Effector Link:", group.get_end_effector_link())\n\n    # Plan to a joint space goal\n    joint_goal = group.get_current_joint_values()\n    joint_goal[0] = 0\n    joint_goal[1] = -0.785\n    joint_goal[2] = 0\n    joint_goal[3] = -2.356\n    joint_goal[4] = 0\n    joint_goal[5] = 1.571\n    joint_goal[6] = 0.785\n\n    # Plan and execute\n    success = group.go(joint_goal, wait=True)\n    group.stop()  # Ensure no residual movement\n\n    print(f"Joint space goal reached: {success}")\n\n    # Plan to a pose goal\n    pose_goal = Pose()\n    pose_goal.orientation.w = 1.0\n    pose_goal.position.x = 0.4\n    pose_goal.position.y = 0.0\n    pose_goal.position.z = 0.3\n\n    group.set_pose_target(pose_goal)\n    success = group.go(wait=True)\n    group.stop()\n    group.clear_pose_targets()\n\n    print(f"Pose goal reached: {success}")\n\nif __name__ == \'__main__\':\n    # For ROS 1\n    if len(sys.argv) > 1 and sys.argv[1] == \'ros1\':\n        rospy.init_node(\'moveit_example\')\n        example = MoveItExample()\n        example.add_collision_objects()\n        example.move_to_pick_pose()\n    # For ROS 2\n    else:\n        rclpy.init()\n        ros2_moveit_example()\n        rclpy.shutdown()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"practical-notes",children:"Practical Notes"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Always test motion plans in simulation before executing on real robots"}),"\n",(0,i.jsx)(e.li,{children:"Configure appropriate joint limits and velocity limits for your robot"}),"\n",(0,i.jsx)(e.li,{children:"Set up proper collision objects in the planning scene"}),"\n",(0,i.jsx)(e.li,{children:"Use appropriate planning algorithms based on your environment complexity"}),"\n",(0,i.jsx)(e.li,{children:"Monitor planning time and success rates to optimize performance"}),"\n",(0,i.jsx)(e.li,{children:"Implement proper error handling for failed planning attempts"}),"\n",(0,i.jsx)(e.li,{children:"Consider the trade-offs between planning time and trajectory quality"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"MoveIt provides a comprehensive framework for motion planning in robotics, integrating collision detection, kinematics, and trajectory generation into a unified system. Understanding MoveIt's architecture and configuration is essential for implementing effective motion planning in robotic manipulation tasks. The framework enables robots to navigate complex environments while avoiding obstacles and respecting physical constraints."}),"\n",(0,i.jsx)(e.h2,{id:"glossary",children:"Glossary"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"MoveIt"}),": ROS/ROS 2 motion planning framework for robotics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Planning Scene"}),": Representation of robot state and environment for motion planning"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Motion Planner"}),": Algorithm that generates collision-free paths for robots"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inverse Kinematics (IK)"}),": Process of determining joint angles for desired end-effector pose"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Collision Detection"}),": System for identifying potential collisions during motion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Trajectory"}),": Time-parameterized path that robot follows during motion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Joint Space"}),": Configuration space defined by robot joint angles"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cartesian Space"}),": 3D space defined by position and orientation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Planning Group"}),": Set of joints that move together as a unit"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"End Effector"}),": Tool or gripper at the end of a robot arm"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Collision Object"}),": Obstacle in the environment that robot must avoid"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Planning Algorithm"}),": Method for finding collision-free paths (RRT, PRM, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"quick-quiz",children:"Quick Quiz"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"What is the primary purpose of MoveIt in robotics?\nA) Robot visualization only\nB) Motion planning and manipulation framework\nC) Sensor data processing\nD) Robot hardware control"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Which of the following is NOT a component of MoveIt's architecture?\nA) Planning Scene\nB) Motion Planners\nC) Collision Detection\nD) Network Protocols"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:'What does "inverse kinematics" refer to in the context of MoveIt?\nA) Calculating end-effector pose from joint angles\nB) Calculating joint angles for desired end-effector pose\nC) Detecting collisions\nD) Generating trajectories'}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:'What is a "planning group" in MoveIt?\nA) A group of robots working together\nB) A set of joints that move together as a unit\nC) A team of roboticists\nD) A category of planning algorithms'}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Which planning algorithm is commonly used in MoveIt?\nA) A* only\nB) Dijkstra only\nC) RRT, RRTConnect, and others\nD) Gradient descent only"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Answers:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"B) Motion planning and manipulation framework"}),"\n",(0,i.jsx)(e.li,{children:"D) Network Protocols"}),"\n",(0,i.jsx)(e.li,{children:"B) Calculating joint angles for desired end-effector pose"}),"\n",(0,i.jsx)(e.li,{children:"B) A set of joints that move together as a unit"}),"\n",(0,i.jsx)(e.li,{children:"C) RRT, RRTConnect, and others"}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>r,x:()=>s});var t=o(6540);const i={},a=t.createContext(i);function r(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);